/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type MemberGroupObservation struct {

	// Use IPv4 addresses as server IPs
	AllowIPv4 *bool `json:"allowIpv4,omitempty" tf:"allow_ipv4,omitempty"`

	// Use IPv6 addresses as server IPs
	AllowIPv6 *bool `json:"allowIpv6,omitempty" tf:"allow_ipv6,omitempty"`

	// The IP list of the Group would be used as pool member IP setting
	GroupPath *string `json:"groupPath,omitempty" tf:"group_path,omitempty"`

	// Limits the max number of pool members to the specified value
	MaxIPListSize *float64 `json:"maxIpListSize,omitempty" tf:"max_ip_list_size,omitempty"`

	// If port is specified, all connections will be sent to this port. If unset, the same port the client connected to will be used
	Port *string `json:"port,omitempty" tf:"port,omitempty"`
}

type MemberGroupParameters struct {

	// Use IPv4 addresses as server IPs
	// +kubebuilder:validation:Optional
	AllowIPv4 *bool `json:"allowIpv4,omitempty" tf:"allow_ipv4,omitempty"`

	// Use IPv6 addresses as server IPs
	// +kubebuilder:validation:Optional
	AllowIPv6 *bool `json:"allowIpv6,omitempty" tf:"allow_ipv6,omitempty"`

	// The IP list of the Group would be used as pool member IP setting
	// +kubebuilder:validation:Required
	GroupPath *string `json:"groupPath" tf:"group_path,omitempty"`

	// Limits the max number of pool members to the specified value
	// +kubebuilder:validation:Optional
	MaxIPListSize *float64 `json:"maxIpListSize,omitempty" tf:"max_ip_list_size,omitempty"`

	// If port is specified, all connections will be sent to this port. If unset, the same port the client connected to will be used
	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`
}

type MemberObservation struct {

	// Member admin state
	AdminState *string `json:"adminState,omitempty" tf:"admin_state,omitempty"`

	// A boolean flag which reflects whether this is a backup pool member
	BackupMember *bool `json:"backupMember,omitempty" tf:"backup_member,omitempty"`

	// Pool member name
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Pool member IP address
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// To ensure members are not overloaded, connections to a member can be capped by the load balancer. When a member reaches this limit, it is skipped during server selection. If it is not specified, it means that connections are unlimited
	MaxConcurrentConnections *float64 `json:"maxConcurrentConnections,omitempty" tf:"max_concurrent_connections,omitempty"`

	// If port is specified, all connections will be sent to this port. Only single port is supported. If unset, the same port the client connected to will be used, it could be overrode by default_pool_member_port setting in virtual server. The port should not specified for port range case
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// Pool member weight is used for WEIGHTED_ROUND_ROBIN balancing algorithm. The weight value would be ignored in other algorithms
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type MemberParameters struct {

	// Member admin state
	// +kubebuilder:validation:Optional
	AdminState *string `json:"adminState,omitempty" tf:"admin_state,omitempty"`

	// A boolean flag which reflects whether this is a backup pool member
	// +kubebuilder:validation:Optional
	BackupMember *bool `json:"backupMember,omitempty" tf:"backup_member,omitempty"`

	// Pool member name
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Pool member IP address
	// +kubebuilder:validation:Required
	IPAddress *string `json:"ipAddress" tf:"ip_address,omitempty"`

	// To ensure members are not overloaded, connections to a member can be capped by the load balancer. When a member reaches this limit, it is skipped during server selection. If it is not specified, it means that connections are unlimited
	// +kubebuilder:validation:Optional
	MaxConcurrentConnections *float64 `json:"maxConcurrentConnections,omitempty" tf:"max_concurrent_connections,omitempty"`

	// If port is specified, all connections will be sent to this port. Only single port is supported. If unset, the same port the client connected to will be used, it could be overrode by default_pool_member_port setting in virtual server. The port should not specified for port range case
	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// Pool member weight is used for WEIGHTED_ROUND_ROBIN balancing algorithm. The weight value would be ignored in other algorithms
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type PolicyLbPoolObservation struct {

	// Active healthcheck is disabled by default and can be enabled using this setting
	ActiveMonitorPath *string `json:"activeMonitorPath,omitempty" tf:"active_monitor_path,omitempty"`

	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// Description for this resource
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Display name for this resource
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// List of server pool members. Each pool member is identified, typically, by an IP address and a port
	Member []MemberObservation `json:"member,omitempty" tf:"member,omitempty"`

	// Dynamic pool members for the loadbalancing pool. When member group is defined, members setting should not be specified
	MemberGroup []MemberGroupObservation `json:"memberGroup,omitempty" tf:"member_group,omitempty"`

	MinActiveMembers *float64 `json:"minActiveMembers,omitempty" tf:"min_active_members,omitempty"`

	// NSX ID for this resource
	NsxID *string `json:"nsxId,omitempty" tf:"nsx_id,omitempty"`

	// Policy path for passive health monitor
	PassiveMonitorPath *string `json:"passiveMonitorPath,omitempty" tf:"passive_monitor_path,omitempty"`

	// Policy path for this resource
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
	Revision *float64 `json:"revision,omitempty" tf:"revision,omitempty"`

	// SNAT configuration
	Snat []SnatObservation `json:"snat,omitempty" tf:"snat,omitempty"`

	TCPMultiplexingEnabled *bool `json:"tcpMultiplexingEnabled,omitempty" tf:"tcp_multiplexing_enabled,omitempty"`

	TCPMultiplexingNumber *float64 `json:"tcpMultiplexingNumber,omitempty" tf:"tcp_multiplexing_number,omitempty"`

	// Set of opaque identifiers meaningful to the user
	Tag []TagObservation `json:"tag,omitempty" tf:"tag,omitempty"`
}

type PolicyLbPoolParameters struct {

	// Active healthcheck is disabled by default and can be enabled using this setting
	// +kubebuilder:validation:Optional
	ActiveMonitorPath *string `json:"activeMonitorPath,omitempty" tf:"active_monitor_path,omitempty"`

	// +kubebuilder:validation:Optional
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// Description for this resource
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Display name for this resource
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// List of server pool members. Each pool member is identified, typically, by an IP address and a port
	// +kubebuilder:validation:Optional
	Member []MemberParameters `json:"member,omitempty" tf:"member,omitempty"`

	// Dynamic pool members for the loadbalancing pool. When member group is defined, members setting should not be specified
	// +kubebuilder:validation:Optional
	MemberGroup []MemberGroupParameters `json:"memberGroup,omitempty" tf:"member_group,omitempty"`

	// +kubebuilder:validation:Optional
	MinActiveMembers *float64 `json:"minActiveMembers,omitempty" tf:"min_active_members,omitempty"`

	// NSX ID for this resource
	// +kubebuilder:validation:Optional
	NsxID *string `json:"nsxId,omitempty" tf:"nsx_id,omitempty"`

	// Policy path for passive health monitor
	// +kubebuilder:validation:Optional
	PassiveMonitorPath *string `json:"passiveMonitorPath,omitempty" tf:"passive_monitor_path,omitempty"`

	// SNAT configuration
	// +kubebuilder:validation:Optional
	Snat []SnatParameters `json:"snat,omitempty" tf:"snat,omitempty"`

	// +kubebuilder:validation:Optional
	TCPMultiplexingEnabled *bool `json:"tcpMultiplexingEnabled,omitempty" tf:"tcp_multiplexing_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	TCPMultiplexingNumber *float64 `json:"tcpMultiplexingNumber,omitempty" tf:"tcp_multiplexing_number,omitempty"`

	// Set of opaque identifiers meaningful to the user
	// +kubebuilder:validation:Optional
	Tag []TagParameters `json:"tag,omitempty" tf:"tag,omitempty"`
}

type SnatObservation struct {

	// List of IP CIDRs or IP ranges for SNAT of type SNAT_IP_POOL
	IPPoolAddresses []*string `json:"ipPoolAddresses,omitempty" tf:"ip_pool_addresses,omitempty"`

	// Type of SNAT performed to ensure reverse traffic from the server can be received and processed by the loadbalancer
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type SnatParameters struct {

	// List of IP CIDRs or IP ranges for SNAT of type SNAT_IP_POOL
	// +kubebuilder:validation:Optional
	IPPoolAddresses []*string `json:"ipPoolAddresses,omitempty" tf:"ip_pool_addresses,omitempty"`

	// Type of SNAT performed to ensure reverse traffic from the server can be received and processed by the loadbalancer
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type TagObservation struct {
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`

	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`
}

type TagParameters struct {

	// +kubebuilder:validation:Optional
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`

	// +kubebuilder:validation:Optional
	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`
}

// PolicyLbPoolSpec defines the desired state of PolicyLbPool
type PolicyLbPoolSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     PolicyLbPoolParameters `json:"forProvider"`
}

// PolicyLbPoolStatus defines the observed state of PolicyLbPool.
type PolicyLbPoolStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        PolicyLbPoolObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// PolicyLbPool is the Schema for the PolicyLbPools API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,nsxt}
type PolicyLbPool struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.displayName)",message="displayName is a required parameter"
	Spec   PolicyLbPoolSpec   `json:"spec"`
	Status PolicyLbPoolStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// PolicyLbPoolList contains a list of PolicyLbPools
type PolicyLbPoolList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []PolicyLbPool `json:"items"`
}

// Repository type metadata.
var (
	PolicyLbPool_Kind             = "PolicyLbPool"
	PolicyLbPool_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: PolicyLbPool_Kind}.String()
	PolicyLbPool_KindAPIVersion   = PolicyLbPool_Kind + "." + CRDGroupVersion.String()
	PolicyLbPool_GroupVersionKind = CRDGroupVersion.WithKind(PolicyLbPool_Kind)
)

func init() {
	SchemeBuilder.Register(&PolicyLbPool{}, &PolicyLbPoolList{})
}
