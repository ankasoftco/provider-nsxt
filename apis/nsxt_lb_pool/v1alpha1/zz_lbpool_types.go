/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type GroupingObjectObservation struct {

	// A boolean flag which will be set to false if the referenced NSX resource has been deleted
	IsValid *bool `json:"isValid,omitempty" tf:"is_valid,omitempty"`

	// Display name of the NSX resource
	TargetDisplayName *string `json:"targetDisplayName,omitempty" tf:"target_display_name,omitempty"`

	// Identifier of the NSX resource
	TargetID *string `json:"targetId,omitempty" tf:"target_id,omitempty"`

	// Type of the NSX resource
	TargetType *string `json:"targetType,omitempty" tf:"target_type,omitempty"`
}

type GroupingObjectParameters struct {

	// Identifier of the NSX resource
	// +kubebuilder:validation:Optional
	TargetID *string `json:"targetId,omitempty" tf:"target_id,omitempty"`

	// Type of the NSX resource
	// +kubebuilder:validation:Optional
	TargetType *string `json:"targetType,omitempty" tf:"target_type,omitempty"`
}

type LbPoolObservation struct {

	// Active health monitor Id. If one is not set, the active healthchecks will be disabled
	ActiveMonitorID *string `json:"activeMonitorId,omitempty" tf:"active_monitor_id,omitempty"`

	// Load balancing algorithm controls how the incoming connections are distributed among the members
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// Description of this resource
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The display name of this resource. Defaults to ID if not set
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// List of server pool members. Each pool member is identified, typically, by an IP address and a port
	Member []MemberObservation `json:"member,omitempty" tf:"member,omitempty"`

	// Dynamic pool members for the loadbalancing pool. When member group is defined, members setting should not be specified
	MemberGroup []MemberGroupObservation `json:"memberGroup,omitempty" tf:"member_group,omitempty"`

	// The minimum number of members for the pool to be considered active
	MinActiveMembers *float64 `json:"minActiveMembers,omitempty" tf:"min_active_members,omitempty"`

	// Passive health monitor Id. If one is not set, the passive healthchecks will be disabled
	PassiveMonitorID *string `json:"passiveMonitorId,omitempty" tf:"passive_monitor_id,omitempty"`

	// The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
	Revision *float64 `json:"revision,omitempty" tf:"revision,omitempty"`

	// SNAT translation configuration
	SnatTranslation []SnatTranslationObservation `json:"snatTranslation,omitempty" tf:"snat_translation,omitempty"`

	// TCP multiplexing allows the same TCP connection between load balancer and the backend server to be used for sending multiple client requests from different client TCP connections
	TCPMultiplexingEnabled *bool `json:"tcpMultiplexingEnabled,omitempty" tf:"tcp_multiplexing_enabled,omitempty"`

	// The maximum number of TCP connections per pool that are idly kept alive for sending future client requests
	TCPMultiplexingNumber *float64 `json:"tcpMultiplexingNumber,omitempty" tf:"tcp_multiplexing_number,omitempty"`

	// Set of opaque identifiers meaningful to the user
	Tag []TagObservation `json:"tag,omitempty" tf:"tag,omitempty"`
}

type LbPoolParameters struct {

	// Active health monitor Id. If one is not set, the active healthchecks will be disabled
	// +kubebuilder:validation:Optional
	ActiveMonitorID *string `json:"activeMonitorId,omitempty" tf:"active_monitor_id,omitempty"`

	// Load balancing algorithm controls how the incoming connections are distributed among the members
	// +kubebuilder:validation:Optional
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// Description of this resource
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The display name of this resource. Defaults to ID if not set
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// List of server pool members. Each pool member is identified, typically, by an IP address and a port
	// +kubebuilder:validation:Optional
	Member []MemberParameters `json:"member,omitempty" tf:"member,omitempty"`

	// Dynamic pool members for the loadbalancing pool. When member group is defined, members setting should not be specified
	// +kubebuilder:validation:Optional
	MemberGroup []MemberGroupParameters `json:"memberGroup,omitempty" tf:"member_group,omitempty"`

	// The minimum number of members for the pool to be considered active
	// +kubebuilder:validation:Optional
	MinActiveMembers *float64 `json:"minActiveMembers,omitempty" tf:"min_active_members,omitempty"`

	// Passive health monitor Id. If one is not set, the passive healthchecks will be disabled
	// +kubebuilder:validation:Optional
	PassiveMonitorID *string `json:"passiveMonitorId,omitempty" tf:"passive_monitor_id,omitempty"`

	// SNAT translation configuration
	// +kubebuilder:validation:Optional
	SnatTranslation []SnatTranslationParameters `json:"snatTranslation,omitempty" tf:"snat_translation,omitempty"`

	// TCP multiplexing allows the same TCP connection between load balancer and the backend server to be used for sending multiple client requests from different client TCP connections
	// +kubebuilder:validation:Optional
	TCPMultiplexingEnabled *bool `json:"tcpMultiplexingEnabled,omitempty" tf:"tcp_multiplexing_enabled,omitempty"`

	// The maximum number of TCP connections per pool that are idly kept alive for sending future client requests
	// +kubebuilder:validation:Optional
	TCPMultiplexingNumber *float64 `json:"tcpMultiplexingNumber,omitempty" tf:"tcp_multiplexing_number,omitempty"`

	// Set of opaque identifiers meaningful to the user
	// +kubebuilder:validation:Optional
	Tag []TagParameters `json:"tag,omitempty" tf:"tag,omitempty"`
}

type MemberGroupObservation struct {

	// Load balancer pool support grouping object as dynamic pool members. The IP list of the grouping object such as NSGroup would be used as pool member IP setting
	GroupingObject []GroupingObjectObservation `json:"groupingObject,omitempty" tf:"grouping_object,omitempty"`

	// Ip revision filter is used to filter IPv4 or IPv6 addresses from the grouping object. If the filter is not specified, both IPv4 and IPv6 addresses would be used as server IPs
	IPVersionFilter *string `json:"ipVersionFilter,omitempty" tf:"ip_version_filter,omitempty"`

	// Specifies whether to limit pool members. If false, dynamic pool can grow up to the load balancer max pool member capacity.
	LimitIPListSize *bool `json:"limitIpListSize,omitempty" tf:"limit_ip_list_size,omitempty"`

	// Limits the max number of pool members to the specified value if limit_ip_list_size is set to true, ignored otherwise.
	MaxIPListSize *float64 `json:"maxIpListSize,omitempty" tf:"max_ip_list_size,omitempty"`

	// If port is specified, all connections will be sent to this port. If unset, the same port the client connected to will be used
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`
}

type MemberGroupParameters struct {

	// Load balancer pool support grouping object as dynamic pool members. The IP list of the grouping object such as NSGroup would be used as pool member IP setting
	// +kubebuilder:validation:Required
	GroupingObject []GroupingObjectParameters `json:"groupingObject" tf:"grouping_object,omitempty"`

	// Ip revision filter is used to filter IPv4 or IPv6 addresses from the grouping object. If the filter is not specified, both IPv4 and IPv6 addresses would be used as server IPs
	// +kubebuilder:validation:Optional
	IPVersionFilter *string `json:"ipVersionFilter,omitempty" tf:"ip_version_filter,omitempty"`

	// Specifies whether to limit pool members. If false, dynamic pool can grow up to the load balancer max pool member capacity.
	// +kubebuilder:validation:Optional
	LimitIPListSize *bool `json:"limitIpListSize,omitempty" tf:"limit_ip_list_size,omitempty"`

	// Limits the max number of pool members to the specified value if limit_ip_list_size is set to true, ignored otherwise.
	// +kubebuilder:validation:Optional
	MaxIPListSize *float64 `json:"maxIpListSize,omitempty" tf:"max_ip_list_size,omitempty"`

	// If port is specified, all connections will be sent to this port. If unset, the same port the client connected to will be used
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`
}

type MemberObservation struct {

	// Member admin state
	AdminState *string `json:"adminState,omitempty" tf:"admin_state,omitempty"`

	// A boolean flag which reflects whether this is a backup pool member
	BackupMember *bool `json:"backupMember,omitempty" tf:"backup_member,omitempty"`

	// Pool member name
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Pool member IP address
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// To ensure members are not overloaded, connections to a member can be capped by the load balancer. When a member reaches this limit, it is skipped during server selection. If it is not specified, it means that connections are unlimited
	MaxConcurrentConnections *float64 `json:"maxConcurrentConnections,omitempty" tf:"max_concurrent_connections,omitempty"`

	// If port is specified, all connections will be sent to this port. Only single port is supported. If unset, the same port the client connected to will be used, it could be overrode by default_pool_member_port setting in virtual server. The port should not specified for port range case
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// Pool member weight is used for WEIGHTED_ROUND_ROBIN balancing algorithm. The weight value would be ignored in other algorithms
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type MemberParameters struct {

	// Member admin state
	// +kubebuilder:validation:Optional
	AdminState *string `json:"adminState,omitempty" tf:"admin_state,omitempty"`

	// A boolean flag which reflects whether this is a backup pool member
	// +kubebuilder:validation:Optional
	BackupMember *bool `json:"backupMember,omitempty" tf:"backup_member,omitempty"`

	// Pool member name
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Pool member IP address
	// +kubebuilder:validation:Required
	IPAddress *string `json:"ipAddress" tf:"ip_address,omitempty"`

	// To ensure members are not overloaded, connections to a member can be capped by the load balancer. When a member reaches this limit, it is skipped during server selection. If it is not specified, it means that connections are unlimited
	// +kubebuilder:validation:Optional
	MaxConcurrentConnections *float64 `json:"maxConcurrentConnections,omitempty" tf:"max_concurrent_connections,omitempty"`

	// If port is specified, all connections will be sent to this port. Only single port is supported. If unset, the same port the client connected to will be used, it could be overrode by default_pool_member_port setting in virtual server. The port should not specified for port range case
	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// Pool member weight is used for WEIGHTED_ROUND_ROBIN balancing algorithm. The weight value would be ignored in other algorithms
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type SnatTranslationObservation struct {

	// Ip address or Ip range for SNAT of type SNAT_IP_POOL
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	// Type of SNAT performed to ensure reverse traffic from the server can be received and processed by the loadbalancer
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type SnatTranslationParameters struct {

	// Ip address or Ip range for SNAT of type SNAT_IP_POOL
	// +kubebuilder:validation:Optional
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	// Type of SNAT performed to ensure reverse traffic from the server can be received and processed by the loadbalancer
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type TagObservation struct {
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`

	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`
}

type TagParameters struct {

	// +kubebuilder:validation:Optional
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`

	// +kubebuilder:validation:Optional
	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`
}

// LbPoolSpec defines the desired state of LbPool
type LbPoolSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     LbPoolParameters `json:"forProvider"`
}

// LbPoolStatus defines the observed state of LbPool.
type LbPoolStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        LbPoolObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// LbPool is the Schema for the LbPools API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,nsxt}
type LbPool struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LbPoolSpec   `json:"spec"`
	Status            LbPoolStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// LbPoolList contains a list of LbPools
type LbPoolList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LbPool `json:"items"`
}

// Repository type metadata.
var (
	LbPool_Kind             = "LbPool"
	LbPool_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: LbPool_Kind}.String()
	LbPool_KindAPIVersion   = LbPool_Kind + "." + CRDGroupVersion.String()
	LbPool_GroupVersionKind = CRDGroupVersion.WithKind(LbPool_Kind)
)

func init() {
	SchemeBuilder.Register(&LbPool{}, &LbPoolList{})
}
